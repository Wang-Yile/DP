# 分块笔记

分块都是 $\text{Sb}$。

> 分块（$\text{Sb}$）是全球性污染物，是国际上最为关注的有毒金属元素之一。与其他有毒金属如汞和砷等相比，人们对分块的环境污染过程和生物地球化学循环还缺乏系统认识。——百度百科

## 数列分块入门 1

> 题意：区间加；单点查询值。

> 解法：散块暴力加，整块打加标记。

代码

```cpp
#include <iostream>
#include <math.h>

#define int long long

using namespace std;

int n;
int a[50005];
int b[50005];
int tag[50005];

static inline void update(int l, int r, int c) {
    if (b[l] == b[r]) {
        for (int i = l; i <= r; ++i) {
            a[i] += c;
        }
        return;
    }
    for (int i = l; b[i] == b[l]; ++i) {
        a[i] += c;
    }
    for (int i = b[l] + 1; i < b[r]; ++i) {
        tag[i] += c;
    }
    for (int i = r; b[i] == b[r]; --i) {
        a[i] += c;
    }
}
static inline int query(int x) {
    return a[x] + tag[b[x]];
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("6277.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    int block_size = sqrt(n);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[i] = i / block_size + 1;
    }
    for (int _ = 1; _ <= n; ++_) {
        int opt, l, r, c;
        cin >> opt >> l >> r >> c;
        if (opt == 0) {
            update(l, r, c);
        } else {
            cout << query(r) << endl;
        }
    }
    return 0;
}
```

## 数列分块入门 2

> 题意：区间加；区间查询小于 $c^2$ 的数的个数。

> 解法：散块暴力，整块打标记。把每个块映射到新数组并从小到大排序，每次查询整块可以二分，散块修改后需要暴力重构那个块。

代码

```cpp
#include <algorithm>
#include <iostream>

#define int long long

using namespace std;

int n;
int a[50005];
int b[50005];
int ls[50005];
int rs[50005];
int val[50005];
int tag[50005];

signed main() {
#ifndef ONLINE_JUDGE
    freopen("6278.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    int block_size = 233;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[i] = i / block_size + 1;
        val[i] = a[i];
    }
    for (int i = b[1]; i <= b[n]; ++i) {
        ls[i] = 1e18;
    }
    for (int i = 1; i <= n; ++i) {
        ls[b[i]] = min(ls[b[i]], i);
        rs[b[i]] = max(rs[b[i]], i);
    }
    for (int i = b[1]; i <= b[n]; ++i) {
        sort(val + ls[i], val + rs[i] + 1);
    }
    for (int _ = 1; _ <= n; ++_) {
        int opt, l, r, c;
        cin >> opt >> l >> r >> c;
        if (opt == 0) {
            if (b[l] == b[r]) {
                for (int i = l; i <= r; ++i) {
                    a[i] += c;
                }
                for (int i = ls[b[l]]; i <= rs[b[l]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[l]], val + rs[b[l]] + 1);
            } else {
                for (int i = l; b[i] == b[l]; ++i) {
                    a[i] += c;
                }
                for (int i = ls[b[l]]; i <= rs[b[l]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[l]], val + rs[b[l]] + 1);
                for (int i = b[l] + 1; i < b[r]; ++i) {
                    tag[i] += c;
                }
                for (int i = r; b[i] == b[r]; --i) {
                    a[i] += c;
                }
                for (int i = ls[b[r]]; i <= rs[b[r]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[r]], val + rs[b[r]] + 1);
            }
        } else {
            c *= c;
            int ans = 0;
            if (b[l] == b[r]) {
                for (int i = l; i <= r; ++i) {
                    if (a[i] + tag[b[i]] < c) {
                        ++ans;
                    }
                }
            } else {
                for (int i = l; b[i] == b[l]; ++i) {
                    if (a[i] + tag[b[i]] < c) {
                        ++ans;
                    }
                }
                for (int i = b[l] + 1; i < b[r]; ++i) {
                    ans += lower_bound(val + ls[i], val + rs[i] + 1, c - tag[i]) - val - ls[i];
                }
                for (int i = r; b[i] == b[r]; --i) {
                    if (a[i] + tag[b[i]] < c) {
                        ++ans;
                    }
                }
            }
            cout << ans << endl;
        }
    }
    return 0;
}
```

## 数列分块入门 3

> 题意：区间加；查询区间比 $c$ 小的最大数。

> 思路：同分块入门 2，二分答案。

代码

```cpp
#include <algorithm>
#include <iostream>

#define int long long

using namespace std;

const int block_size = 320;

int n;
int a[100005];
int b[100005];
int ls[325];
int rs[325];
int tag[325];
int val[100005];

signed main() {
#ifndef ONLINE_JUDGE
    freopen("6279_1.in", "r", stdin);
    freopen("sb.out", "w", stdout);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        val[i] = a[i];
        b[i] = i / block_size + 1;
        rs[b[i]] = i;
    }
    for (int i = b[1]; i <= b[n]; ++i) {
        ls[i] = rs[i - 1] + 1;
        sort(val + ls[i], val + rs[i] + 1);
    }
    for (int _ = 1; _ <= n; ++_) {
        int opt, l, r, c;
        cin >> opt >> l >> r >> c;
        if (opt == 0) {
            if (b[l] == b[r]) {
                for (int i = l; i <= r; ++i) {
                    a[i] += c;
                }
                for (int i = ls[b[l]]; i <= rs[b[l]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[l]], val + rs[b[l]] + 1);
            } else {
                for (int i = l; i <= rs[b[l]]; ++i) {
                    a[i] += c;
                }
                for (int i = ls[b[l]]; i <= rs[b[l]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[l]], val + rs[b[l]] + 1);
                for (int i = b[l] + 1; i < b[r]; ++i) {
                    tag[i] += c;
                }
                for (int i = r; i >= ls[b[r]]; --i) {
                    a[i] += c;
                }
                for (int i = ls[b[r]]; i <= rs[b[r]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[r]], val + rs[b[r]] + 1);
            }
        } else {
            int ans = -1e18;
            if (b[l] == b[r]) {
                for (int i = l; i <= r; ++i) {
                    if (a[i] + tag[b[l]] < c) {
                        ans = max(ans, a[i] + tag[b[l]]);
                    }
                }
            } else {
                for (int i = l; i <= rs[b[l]]; ++i) {
                    if (a[i] + tag[b[i]] < c) {
                        ans = max(ans, a[i] + tag[b[i]]);
                    }
                }
                for (int i = b[l] + 1; i < b[r]; ++i) {
                    auto it = lower_bound(val + ls[i], val + rs[i] + 1, c - tag[i]) - 1;
                    if (it >= val + ls[i] && it <= val + rs[i]) {
                        ans = max(ans, (*it) + tag[i]);
                    }
                }
                for (int i = r; i >= ls[b[r]]; --i) {
                    if (a[i] + tag[b[i]] < c) {
                        ans = max(ans, a[i] + tag[b[i]]);
                    }
                }
            }
            if (ans == -1e18) {
                cout << -1 << endl;
            } else {
                cout << ans << endl;
            }
        }
    }
    return 0;
}
```
