# 分块笔记

分块都是 $\text{Sb}$。

> 分块（$\text{Sb}$）是全球性污染物，是国际上最为关注的有毒金属元素之一。与其他有毒金属如汞和砷等相比，人们对分块的环境污染过程和生物地球化学循环还缺乏系统认识。——百度百科

<details open>

<summary>
数列分块入门 1
</summary>

> 题意：区间加；单点查询值。

> 解法：散块暴力加，整块打加标记。

<details>

<summary>
代码
</summary>

本题当然可以写线段树。

```cpp
#include <iostream>
#include <math.h>

#define int long long

using namespace std;

int n;
int a[50005];
int b[50005];
int tag[50005];

static inline void update(int l, int r, int c) {
    if (b[l] == b[r]) {
        for (int i = l; i <= r; ++i) {
            a[i] += c;
        }
        return;
    }
    for (int i = l; b[i] == b[l]; ++i) {
        a[i] += c;
    }
    for (int i = b[l] + 1; i < b[r]; ++i) {
        tag[i] += c;
    }
    for (int i = r; b[i] == b[r]; --i) {
        a[i] += c;
    }
}
static inline int query(int x) {
    return a[x] + tag[b[x]];
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("6277.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    int block_size = sqrt(n);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[i] = i / block_size + 1;
    }
    for (int _ = 1; _ <= n; ++_) {
        int opt, l, r, c;
        cin >> opt >> l >> r >> c;
        if (opt == 0) {
            update(l, r, c);
        } else {
            cout << query(r) << endl;
        }
    }
    return 0;
}
```

</details>

</details>

<details open>

<summary>
数列分块入门 2
</summary>

> 题意：区间加；区间查询小于 $c^2$ 的数的个数。

> 解法：散块暴力，整块打标记。把每个块映射到新数组并从小到大排序，每次查询整块可以二分，散块修改后需要暴力重构那个块。

<details>

<summary>
代码
</summary>

```cpp
#include <algorithm>
#include <iostream>

#define int long long

using namespace std;

int n;
int a[50005];
int b[50005];
int ls[50005];
int rs[50005];
int val[50005];
int tag[50005];

signed main() {
#ifndef ONLINE_JUDGE
    freopen("6278.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    int block_size = 233;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[i] = i / block_size + 1;
        val[i] = a[i];
    }
    for (int i = b[1]; i <= b[n]; ++i) {
        ls[i] = 1e18;
    }
    for (int i = 1; i <= n; ++i) {
        ls[b[i]] = min(ls[b[i]], i);
        rs[b[i]] = max(rs[b[i]], i);
    }
    for (int i = b[1]; i <= b[n]; ++i) {
        sort(val + ls[i], val + rs[i] + 1);
    }
    for (int _ = 1; _ <= n; ++_) {
        int opt, l, r, c;
        cin >> opt >> l >> r >> c;
        if (opt == 0) {
            if (b[l] == b[r]) {
                for (int i = l; i <= r; ++i) {
                    a[i] += c;
                }
                for (int i = ls[b[l]]; i <= rs[b[l]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[l]], val + rs[b[l]] + 1);
            } else {
                for (int i = l; b[i] == b[l]; ++i) {
                    a[i] += c;
                }
                for (int i = ls[b[l]]; i <= rs[b[l]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[l]], val + rs[b[l]] + 1);
                for (int i = b[l] + 1; i < b[r]; ++i) {
                    tag[i] += c;
                }
                for (int i = r; b[i] == b[r]; --i) {
                    a[i] += c;
                }
                for (int i = ls[b[r]]; i <= rs[b[r]]; ++i) {
                    val[i] = a[i];
                }
                sort(val + ls[b[r]], val + rs[b[r]] + 1);
            }
        } else {
            c *= c;
            int ans = 0;
            if (b[l] == b[r]) {
                for (int i = l; i <= r; ++i) {
                    if (a[i] + tag[b[i]] < c) {
                        ++ans;
                    }
                }
            } else {
                for (int i = l; b[i] == b[l]; ++i) {
                    if (a[i] + tag[b[i]] < c) {
                        ++ans;
                    }
                }
                for (int i = b[l] + 1; i < b[r]; ++i) {
                    ans += lower_bound(val + ls[i], val + rs[i] + 1, c - tag[i]) - val - ls[i];
                }
                for (int i = r; b[i] == b[r]; --i) {
                    if (a[i] + tag[b[i]] < c) {
                        ++ans;
                    }
                }
            }
            cout << ans << endl;
        }
    }
    return 0;
}
```

</details>

</details>
